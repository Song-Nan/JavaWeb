# Linux:

#### grep:

过滤任务  经常和其他命令联合使用

grep -i  名称

#### | 管道符：

​	a |  b a的输出作为b的输入

#### Kill命令：

kill   -9   pid 		kill -9  3349;

#### ping



#### 解压缩：

tar -zcvf  xxx.tar  源文件名     压缩文件

tar -axvf xxx.tar		解压文件



#### 网络配置：

如果虚拟机安装完毕后，看不到对应的2个虚拟网卡，可以在/etc/sysconfig/networt-scripts/ifcfg-eth0里面更改  ONBOOT = yes  和  BOOTPROTO  = dhcp;

查看各个命令的参数：

​	内部命令：系统自带的命令：help  +命令

​	外部命令：系统之外添加的：man + 命令 

 



# makefile

1，make（linux自带的构建器），构建的规则在makefile中。

2，makefile文件的命名

​	-makefile

​	-Makefile

3,makefile中的规则







# 进程：

## 1，进程和程序

### 什么是程序：

编译好的二进制文件。

### 什么是进程：

运行着的程序。站在程序员的角度：运行一系列指令的过程。站在操作系统的角度：分配系统资源的基本单位。

### 二者的区别：

程序只占用磁盘空间，不占用系统资源

一个程序对应多个进程，一个进程对应一个程序。

程序没有生命周期，进程没有生命周期。

### 进程的状态转换：

状态：就绪、运行、挂起、终止。

任何状态都可以转换为终止态

## 环境变量：

写法：

​	key=value:   不能有空格

查看环境变量：env

查看某个环境变量：echo $PATH

## 进程api:

fork：pid_t fork (void);返回值	：-1：失败  ； 成功返回两次：父进程返回子进程的id，子进程返回0；



#### ps ajx 查看进程pid和父进程pid之间的练习





# 进程共享：

父子相同之处：<font color="red">全局变量</font>、大他、text、栈，堆，环境变量，用户id，宿主目录，进程工作目录，信号处理方式。

父子不同之处：进程id，fork返回值，父进程id，进程运行时间，未决信号集。

###### 即使是全局变量，也不是真的共享，只是“读时共享，写时复制”

## exec函数族：

执行其他程序：

int execl(const char **path,const char*arg,); 

int execl(const char * file(程序）,const char * _arg（参数） , ...    /*（char * null * /);

​	file	:要执行的程序。

​	arg	:参数列表，从arg[0]开始，参数列表的最后需要一个null作为结尾，作为哨兵。

​	执行的程序必须是系统命令

​	返回值：只有失败才返回，

## 孤儿进程和僵尸进程：

#### 孤儿进程：

父进程死了，子进程被init进程领养，释放不了pcb，必须由父进程来释放。

#### 僵尸进程：

子进程死了，父进程没有释放子进程的资源（pcb)

僵尸进程：对系统有危害，浪费系统资源，

orphan：孤儿，

##### 僵尸进程如何回收子进程的资源： 杀掉父进程，让init进程领养负责回收。

### 子进程回收：  

回收子进程得知道进程死亡的原因：

阻塞等待：阻塞等待子进程的死亡

​		：回收子进程资源

​		：查看死亡原因 

pid_t   wait  (int  * status);

​	status：传出参数。

​	返回值：成功返回终止的子进程id，失败返回-1.

​	子进程的死亡原因：

​		正常死亡：WIFEXITED:如果为真，使用WEXITSTATUS得到退出状态

​		非正常死亡：WIFSIGNALED:如果为真，使用WTERMSIG得到信号